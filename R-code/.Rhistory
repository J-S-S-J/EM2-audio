library(tidyverse)
path <- "~/Desktop/Python/EM2-audio/experiment/control_experiment/data_detection/god_data"
all_files <- fs::dir_ls(path, glob = "*.csv")
path <- "~/Desktop/Python/EM2-audio/experiment/control_experiment/data_detection/gammel_data"
all_files <- fs::dir_ls(path, glob = "*.csv")
raw_data <- map_dfr(all_files, read_csv, .id = "source_file")
library(tidyverse)
path <- "~/Desktop/Python/EM2-audio/experiment/control_experiment/data_detection/gammel_data"
all_files <- fs::dir_ls(path, glob = "*.csv")
raw_data <- map_dfr(all_files, read_csv, .id = "source_file")
tidy_data <- raw_data %>%
# --- Remove Practice Trials ---
# This logic is still correct. We keep rows where the 'main'
# loop was running (i.e., 'main.thisN' is not NA).
filter(!is.na(main.thisN)) %>%
# --- Select Only the Useful Columns ---
# We use the REAL column names from your glimpse() output.
# Use backticks `` for names with spaces like `Participant ID`.
select(
# Participant info
participant = `Participant ID`, # Rename `Participant ID` to `participant`
session = Session,          # Rename `Session` to `session`
# Trial info
trial_num = main.thisN,     # This is the trial number
# Experiment condition columns (from your data)
signal_type,
compression_level,
prime_file,
correct_word,
babbling_file,
mask1_file,
mask2_file,
# Dependent Variables (the participant's response)
key_pressed = response_key, # Rename `response_key` to `key_pressed`
rt,
trial_outcome
) %>%
# --- Fix Data Types ---
# Convert columns to the correct type for analysis
mutate(
# Convert RT to numeric
rt = as.numeric(rt),
# Convert key identifiers to factors (categorical variables)
participant = as.factor(participant),
session = as.factor(session),
key_pressed = as.factor(key_pressed),
# Convert valences to factors
signal_type = as.factor(signal_type),
trial_outcome = as.factor(trial_outcome)
)
# 4. SHOW THE RESULT
#------------------------------------------------------------------
# Print the first few rows of your new, clean data frame
print(tidy_data)
# Show a summary of the data frame structure
glimpse(tidy_data)
# Load the ggplot2 library (part of tidyverse)
library(ggplot2)
# Create the 100% stacked bar chart
# We use the 'tidy_data' data frame from the previous step
compression_plot <- ggplot(tidy_data, aes(x = factor(compression_level), fill = trial_outcome)) +
# geom_bar(position = "fill") creates a 100% stacked bar chart,
# which is perfect for comparing proportions across groups.
geom_bar(position = "fill") +
# Add clear labels
labs(
title = "Proportion of Trial Outcomes by Compression Level",
x = "Compression Level",
y = "Proportion",
fill = "Trial Outcome"
) +
# Format the y-axis to show percentages (e.g., 25%, 50%)
scale_y_continuous(labels = scales::percent_format()) +
# Apply a clean theme
theme_minimal()
# Save the plot to a file
ggsave("compression_outcomes_plot.png", plot = compression_plot, width = 10, height = 6)
# Print the plot object so it displays
print(compression_plot)
path <- "~/Desktop/Python/EM2-audio/experiment/control_experiment/data_detection/ny_data"
all_files <- fs::dir_ls(path, glob = "*.csv")
raw_data <- map_dfr(all_files, read_csv, .id = "source_file")
library(tidyverse)
path <- "~/Desktop/Python/EM2-audio/experiment/control_experiment/data_detection/ny_data"
all_files <- fs::dir_ls(path, glob = "*.csv")
raw_data <- map_dfr(all_files, read_csv, .id = "source_file")
tidy_data <- raw_data %>%
# --- Remove Practice Trials ---
# This logic is still correct. We keep rows where the 'main'
# loop was running (i.e., 'main.thisN' is not NA).
filter(!is.na(main.thisN)) %>%
# --- Select Only the Useful Columns ---
# We use the REAL column names from your glimpse() output.
# Use backticks `` for names with spaces like `Participant ID`.
select(
# Participant info
participant = `Participant ID`, # Rename `Participant ID` to `participant`
session = Session,          # Rename `Session` to `session`
# Trial info
trial_num = main.thisN,     # This is the trial number
# Experiment condition columns (from your data)
signal_type,
compression_level,
prime_file,
correct_word,
babbling_file,
mask1_file,
mask2_file,
# Dependent Variables (the participant's response)
key_pressed = response_key, # Rename `response_key` to `key_pressed`
rt,
trial_outcome
) %>%
# --- Fix Data Types ---
# Convert columns to the correct type for analysis
mutate(
# Convert RT to numeric
rt = as.numeric(rt),
# Convert key identifiers to factors (categorical variables)
participant = as.factor(participant),
session = as.factor(session),
key_pressed = as.factor(key_pressed),
# Convert valences to factors
signal_type = as.factor(signal_type),
trial_outcome = as.factor(trial_outcome)
)
# 4. SHOW THE RESULT
#------------------------------------------------------------------
# Print the first few rows of your new, clean data frame
print(tidy_data)
# Show a summary of the data frame structure
glimpse(tidy_data)
# Load the ggplot2 library (part of tidyverse)
library(ggplot2)
# Create the 100% stacked bar chart
# We use the 'tidy_data' data frame from the previous step
compression_plot <- ggplot(tidy_data, aes(x = factor(compression_level), fill = trial_outcome)) +
# geom_bar(position = "fill") creates a 100% stacked bar chart,
# which is perfect for comparing proportions across groups.
geom_bar(position = "fill") +
# Add clear labels
labs(
title = "Proportion of Trial Outcomes by Compression Level",
x = "Compression Level",
y = "Proportion",
fill = "Trial Outcome"
) +
# Format the y-axis to show percentages (e.g., 25%, 50%)
scale_y_continuous(labels = scales::percent_format()) +
# Apply a clean theme
theme_minimal()
# Save the plot to a file
ggsave("compression_outcomes_plot.png", plot = compression_plot, width = 10, height = 6)
# Print the plot object so it displays
print(compression_plot)
library(tidyverse)
path <- "~/Desktop/Python/EM2-audio/R-code/combined_data.csv"
raw_df <- read_delim(path) |>
# 1. Group by Participant so the counting restarts for every person
group_by(`Participant ID`) |>
# 2. Create the new correct trial index (1 to N)
mutate(trial_i = row_number()) |>
# 3. Ungroup so future analyses aren't restricted to one participant
ungroup()
glimpse(raw_df)
raw_df |>
# 1. Filter out no-prime
# filter(prime_valence != "no-prime") |>
# 2. Reorder the Prime Valence so it reads logically (Neg -> Neu -> Pos)
mutate(prime_valence = factor(prime_valence,
levels = c("negative", "neutral", "positive", "no-prime"))) |>
# 3. Setup the plot: Prime on X, Rating on Y
ggplot(aes(x = prime_valence, y = response_key, fill = prime_valence)) +
# 4. Use Boxplots to show the median and spread of the data
geom_boxplot(alpha = 0.6, outlier.alpha = 0.2) +
# 5. Add a large point to show the MEAN (average) which is often what we care about
stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "white") +
# 6. Facet by the actual expression of the face (Optional, but highly recommended)
facet_wrap(~facial_expression) +
# 7. Labels and Theme
labs(title = "Effect of Prime Valence on Ratings",
subtitle = "White diamond indicates the mean rating",
y = "Rating (Response Key)",
x = "Prime Valence") +
theme_minimal() +
scale_fill_brewer(palette = "Set2") # Nice distinct colors
summary_stats <- raw_df |>
filter(prime_valence != "no-prime") |>
mutate(prime_valence = factor(prime_valence, levels = c("negative", "neutral", "positive"))) |>
group_by(facial_expression, prime_valence) |>
summarise(
mean_rating = mean(response_key, na.rm = TRUE),
se = sd(response_key, na.rm = TRUE) / sqrt(n()), # Standard Error
.groups = "drop"
)
raw_df |>
filter(prime_valence != "no-prime", facial_expression != "Neutral") |> # Neutral is hard to define for congruency
# Create a Congruency Column
mutate(
congruency = case_when(
prime_valence == "positive" & facial_expression == "Happy" ~ "Congruent",
prime_valence == "negative" & facial_expression == "Angry" ~ "Congruent",
prime_valence == "positive" & facial_expression == "Angry" ~ "Incongruent",
prime_valence == "negative" & facial_expression == "Happy" ~ "Incongruent",
TRUE ~ NA_character_
)
) |>
filter(!is.na(congruency)) |> # Remove leftovers
# Plotting
ggplot(aes(x = congruency, y = rt, fill = congruency)) +
# Violin shows distribution shape
geom_violin(alpha = 0.5, trim = FALSE) +
# Boxplot inside shows the median and interquartile range
geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA) +
# Facet by expression to see if the effect holds for both emotions
facet_wrap(~facial_expression) +
scale_fill_manual(values = c("Congruent" = "#00BA38", "Incongruent" = "#F8766D")) +
coord_cartesian(ylim = c(0, 4)) + # Zoom in (ignoring extremely long RTs > 4s for clarity)
labs(
title = "Reaction Time by Congruency",
subtitle = "Does matching the prime to the face speed up processing?",
y = "Reaction Time (seconds)",
x = "Condition"
) +
theme_light()
raw_df |>
filter(prime_valence != "no-prime") |>
ggplot(aes(x = pleasure, y = response_key, color = facial_expression)) +
# Add 'jitter' to handle overlapping points (since rating is 1-9 integers)
geom_jitter(alpha = 0.1, height = 0.2, width = 0) +
# Add a smoothing line (Linear Model) to see the trend
geom_smooth(method = "lm", se = TRUE, aes(fill = facial_expression)) +
labs(
title = "Effect of Prime Word 'Pleasure' Score on Ratings",
subtitle = "Do stronger positive words lead to higher ratings?",
x = "Word Pleasure Score (0-100)",
y = "Face Valence Rating",
color = "Target Face",
fill = "Target Face"
) +
theme_minimal()
raw_df |>
filter(prime_valence != "no-prime") |>
ggplot(aes(x = prime_valence, y = response_key, fill = prime_valence)) +
stat_summary(fun = mean, geom = "bar", position = "dodge") +
stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.2) +
# Facet by facial_expression to see if Neutral behaves differently than the strong emotions
facet_wrap(~facial_expression) +
labs(title = "Is the Null Effect Universal?",
subtitle = "Check 'Neutral': If bars are flat everywhere, faces ignore words completely.",
y = "Mean Rating") +
theme_minimal() +
coord_cartesian(ylim = c(1, 9)) # Zoom in on the rating scale
avg_by_participant <- raw_df |>
filter(prime_valence %in% c("negative", "positive")) |> # Compare extremes only
group_by(`Participant ID`, prime_valence) |>
summarise(mean_rating = mean(response_key, na.rm = TRUE), .groups = "drop")
avg_by_participant |>
ggplot(aes(x = prime_valence, y = mean_rating, group = `Participant ID`)) +
# Draw a faint line for EVERY participant
geom_line(alpha = 0.2) +
# Add the group average in Red to show the 'Null' result
stat_summary(aes(group = 1), fun = mean, geom = "line", color = "red", linewidth = 2) +
labs(title = "Individual Variability in Priming",
subtitle = "Grey lines = Participants. Red line = Group Average.\nIf grey lines cross like an X, the effect varies by person.",
y = "Mean Valence Rating") +
theme_minimal()
raw_df |>
filter(prime_valence != "no-prime") |>
ggplot(aes(x = trial_i, y = response_key, color = prime_valence)) +
geom_smooth(method = "loess", se = TRUE) +
labs(title = "Effect of Time on Priming (Fatigue Check)",
subtitle = "With corrected trial numbering. Do the lines merge on the right?",
x = "Chronological Trial Number",
y = "Smoothed Rating") +
theme_minimal()
# 1. Calculate the 'Priming Effect' for each participant
participant_effect <- raw_df |>
filter(prime_valence %in% c("positive", "negative")) |>
group_by(`Participant ID`, prime_valence) |>
summarise(mean_rating = mean(response_key, na.rm = TRUE), .groups = "drop") |>
pivot_wider(names_from = prime_valence, values_from = mean_rating) |>
mutate(diff = positive - negative) |>
arrange(desc(diff)) # Sort from highest difference to lowest
# 2. Extract the ID of the top participant
top_participant_id <- participant_effect$`Participant ID`[1]
top_diff_score <- participant_effect$diff[1]
print(paste("The strongest responder is Participant:", top_participant_id))
print(paste("Difference between Positive and Negative conditions:", round(top_diff_score, 2)))
raw_df |>
# Filter for the specific participant AND remove no-prime
filter(`Participant ID` == top_participant_id,
prime_valence != "no-prime") |>
# Reorder factors for logical plotting
mutate(prime_valence = factor(prime_valence,
levels = c("negative", "neutral", "positive"))) |>
# Plot
ggplot(aes(x = prime_valence, y = response_key, fill = prime_valence)) +
# Boxplot with transparency
geom_boxplot(alpha = 0.6, outlier.alpha = 0.2) +
# Add the MEAN point (White Diamond)
stat_summary(fun = mean, geom = "point", shape = 23, size = 4, fill = "white", stroke = 1.5) +
# Facet by facial expression
facet_wrap(~facial_expression) +
# Custom Labels including the specific ID
labs(title = paste("Data for Best Responder:", top_participant_id),
subtitle = paste("This participant showed a valence shift of", round(top_diff_score, 2), "points."),
y = "Rating (Response Key)",
x = "Prime Valence") +
theme_minimal() +
scale_fill_brewer(palette = "Set2")
